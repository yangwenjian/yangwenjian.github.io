


=======================================
设计模式Head First
=======================================

策略模式
---------------------------------------

将不变的属性作为继承，将变化的属性作为接口并拥有，可以减少变化带来的麻烦，减少代码工作量
鸭子将本身属性种类，羽毛等作为基类的属性，将行为单独抽象为一个接口，并按具体的行为实现这个接口
所有鸭子都有setBehavior方法，进行具体的行为设置

观察者模式
---------------------------------------

观察者模式是将观察者加入到主题的观察者列表中，如果有更新或者发现，可以推送给每个观察者;
或者让观察者拥有我们的当前主题，观察者可以自行拉取想要的内容;
不要针对实现的编程，我们应该针对接口的编程，这样可以解耦，不依赖具体实现;

装饰者模式
---------------------------------------

装饰者模式主要是为解决滥用继承带来的代码混乱的问题，例如不同的咖啡配上不同的佐料，不能一一继承;
我们可以使用一个简单的嵌套（装饰者），每加一层佐料，就在外层加一套嵌套，每个类不仅继承自A，并且还有拥有一个A对象;
这样就可以无限的进行扩展，而不会使得代码膨胀，动态地经责任附加到对象上。
当然这样也有缺点，就是外层对象不知道自己含有什么内容，而且包裹层数多了也不利于可读性

工厂模式
---------------------------------------

工厂模式是为了解耦new实例化对象代码所产生的，为的是针对接口的编程，而不是针对实现的编程，将“实现”从“使用”中解耦，也就是将两者完全分离，是工厂模式的核心思想。
抽象工厂方法把每个抽象工厂中的生产对象的方式都改为工厂模式，定义了一组产品的接口，工厂方法就潜伏在抽象工厂里，
依赖倒置原则(Dependency Inversion Principle)的通用原则是：*依赖抽象，不要依赖具体类*。
google在这方面走的跟进一步，实现了guice(音/'dgus/)，解决DI(Dependency Injector)问题，具体请参考guice分析与实现

单例模式
---------------------------------------
单例模式大家都很熟悉了，这里介绍下扩展：
急切的单例模式，就是在静态变量一开始就初始化好，getInstance方法中直接返回这个对象;
双重检查加锁模式，在getInstance方法中判断对象是否为空，如果为空，对整个类进行加锁，然后创建对象并返回，这样可以避免给整个方法加锁后性能下降的问题

命令模式
---------------------------------------
命令模式是为了解耦调用者和被调用者实现而设计的。其基础是以下接口：

.. code:: java

    public interface Command{
        public void execute();
        public void undo();
    }

也可以进行组合命令，实现一个组合命令继承自Command，拥有一个command数组，之后通过这个数组实现一系列命令，进行多命令的实现。
命令模式可以用作队列请求，

适配器模式
--------------------------------------
适配器模式的主要目的是解决接口间不兼容的问题,其定义是将一类的接口，转换成客户期望的另一个接口。
适配器让原本接口不兼容的类可以合作无间。
适配器实现目标接口，有一个被适配的类型对象。

外观模式
--------------------------------------
提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。

**设计原则--最少知识原则：只和你的密友谈话。(减少耦合)**

模板模式
--------------------------------------
在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
例如将一段算法中的某个步骤提炼为一个抽象方法，而骨架不变，其他设置成final不可覆盖，子类实现这个抽象方法即可。   
也可以在算法的骨架中设计一个hook，一个bool被子类覆盖的bool方法，这样可以实现控制某些算法是否执行。
钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。

**设计原则--好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。**

好莱坞原则提供给我们一个防止“依赖腐败”的方法。（高层组件依赖底层组件，底层组件依赖高层组件，高层组件依赖边侧组件，鞭策组件又依赖底层组建）在好莱坞的原则下，底层组件使用hook挂钩到系统之上，底层系统不调用高层系统，让高层系统调用底层系统。Applet就是一个子类使用hook的好例子，包括init、repaint、start、stop、paint等。

迭代器模式
--------------------------------------
迭代器模式是为解决集合具体实现的不同来统一封装遍历的接口。不论是哪种具体类型的集合，只要实现createIterator接口即可，然后使用iterator的hasNext和next方法进行调用

**设计原则：一个类应该只有一个引起变化的原因**

组合模式
---------------------------------------
组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
其本质是利用组合形成递归原则，将叶子和子节点一视同仁，进行操作。

状态模式
---------------------------------------
状态模式允许对象在内部状态改变时改变它的行为，对想看起来好像修改了它的类。
直观来说，是一个类里包含了自己的几种状态，通过外部调用进而切换自己的状态，

代理模式
--------------------------------------
代理模式为另一个对象提供一个替身或者占位符以控制对这个对象的访问。
具体是生成一个代理对象，用户调用它就像调用真正的对象一样，代理对象进行权限和访问控制。
代理和适配器模式的区别在于适配器转换了真正对象的接口，而代理则实现相同的接口。
Java的RMI正式远程代理的一个实现。

模式的模式
--------------------------------------
模式通常被一起使用，并被组合在一个设计模式解决方案中。
符合模式在一个解决方案中结合两个或者多个模式，以解决一般或重复发生的问题。

