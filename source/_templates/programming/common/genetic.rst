

=====================================
June
=====================================


Genetic Agorithm
=====================================

定义
-------------------------------------
借鉴生物进化论，遗传算法将要解决的问题模拟成一个生物进化的过程，通过复制、交叉、突变等操作产生下一代的解，并逐步淘汰掉适应度函数值低的解，增加适应度函数值高的解。这样进化N代后就很有可能会进化出适应度函数值很高的个体。
种群(Population)：生物的进化以群体的形式进行，这样的一个群体称为种群。

个体：组成种群的单个生物。

基因 ( Gene ) ：一个遗传因子。 

染色体 ( Chromosome ) ：包含一组的基因。

生存竞争，适者生存：对环境适应度高的、牛B的个体参与繁殖的机会比较多，后代就会越来越多。适应度低的个体参与繁殖的机会比较少，后代就会越来越少。

遗传与变异：新个体会遗传父母双方各一部分的基因，同时有一定的概率发生基因变异。

简单说来就是：繁殖过程，会发生基因交叉( Crossover ) ，基因突变 ( Mutation ) ，适应度( Fitness )低的个体会被逐步淘汰，而适应度高的个体会越来越多。那么经过N代的自然选择后，保存下来的个体都是适应度很高的，其中很可能包含史上产生的适应度最高的那个个体。

举个例子，使用遗传算法解决“0-1背包问题”的思路：0-1背包的解可以编码为一串0-1字符串（0：不取，1：取） ；首先，随机产生M个0-1字符串，然后评价这些0-1字符串作为0-1背包问题的解的优劣；然后，随机选择一些字符串通过交叉、突变等操作产生下一代的M个字符串，而且较优的解被选中的概率要比较高。这样经过G代的进化后就可能会产生出0-1背包问题的一个“近似最优解”。

遗传算法的组成
-------------------------------------
1.编码（产生初始种群）
2.适应度函数


本质
-------------------------------------
对于一个复杂问题，遗传算法的本质是穷举法的生物启发优化算法（我起的称呼），例如TSP（旅行商）问题，我们用穷举法肯定能找到最优解，但是穷举法会浪费大量的资源，而且运算周期肯定长的不可接受，为N!次，会随着N的增加成爆炸性增长。
遗传算法正是利用了生物学的物竞田择，适者生存的自然规律，对一个问题的N个解进行选择（也就是淘汰差的），交叉（也就是强强交配），变异（随机突变），一代代进行优化，最终得出不能再优化的解。

算法步骤
-------------------------------------
编码：需要将问题的解编码成字符串的形式才能使用遗传算法。最简单的一种编码方式是二进制编码，即将问题的解编码成二进制位数组的形式。例如，问题的解是整数，那么可以将其编码成二进制位数组的形式。将0-1字符串作为0-1背包问题的解就属于二进制编码。

遗传算法有3个最基本的操作：选择，交叉，变异

选择：选择一些染色体来产生下一代。一种常用的选择策略是 “比例选择”，也就是个体被选中的概率与其适应度函数值成正比。假设群体的个体总数是M，那么那么一个体Xi被选中的概率为f(Xi)/( f(X1) + f(X2) + …….. + f(Xn) ) ;

交叉(Crossover)：2条染色体交换部分基因，来构造下一代的2条新的染色体;

变异(Mutation)：在繁殖过程，新产生的染色体中的基因会以一定的概率出错，称为变异。变异发生的概率记为Pm;

为代码如下：

.. code::

    initialize P(0);
    t = 0;             //t是进化的代数，一代、二代、三代...
    while(t <= T) do
        for i = 1 to M  do     //M是初始种群的个体数
            Evaluate fitness of P(t);  //计算P（t）中各个个体的适应度
        end for
        for i = 1 to M  do
            Select operation to P(t);  //将选择算子作用于群体
        end for
        for i = 1 to M/2  do
            Crossover operation to P(t); //将交叉算子作用于群体
        end for
        for i = 1 to M  do
            Mutation operation to P(t);  //将变异算子作用于群体
        end for
        for i = 1 to M  do
            P(t+1) = P(t);      //得到下一代群体P（t + 1）
        end for
        t = t + 1;      //终止条件判断  t≦T：t← t+1 转到步骤2
    end while

遗传算法除了上述这些几个主要算子之外，还有一些细节。如交叉概率pc，变异概率pm，这些虽然都是辅助手段，但是有时候对整个算法结果和性能带来截然不同的效果。这也是启发式算法的一个缺点。参数需要不停的在实践中摸索，没有万能的推荐参数

遗传算法的优化
-------------------------------------
精英主义(Elitist Strategy)选择：是基本遗传算法的一种优化。为了防止进化过程中产生的最优解被交叉和变异所破坏，可以将每一代中的最优解原封不动的复制到下一代中。
插入操作：可在3个基本操作的基础上增加一个插入操作。插入操作将染色体中的某个随机的片段移位到另一个随机的位置。

桥梁施工管理优化问题
-------------------------------------
关于桥梁工程，这里我简单介绍下（因为我也不懂，哈哈）
