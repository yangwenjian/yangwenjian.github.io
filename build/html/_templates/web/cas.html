<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cas &mdash; knight 1.0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="knight 1.0.1 documentation" href="../../index.html" />
    <link rel="next" title="Web Performance" href="../performance/web_performance.html" />
    <link rel="prev" title="Web Page Design" href="webpage.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../performance/web_performance.html" title="Web Performance"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="webpage.html" title="Web Page Design"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">knight 1.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Cas</a><ul>
<li><a class="reference internal" href="#id1">Cas介绍</a><ul>
<li><a class="reference internal" href="#id2">相关概念</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">Cas流程</a></li>
<li><a class="reference internal" href="#cas-ha-deployment">Cas HA Deployment</a></li>
<li><a class="reference internal" href="#cas-security">Cas Security</a></li>
<li><a class="reference internal" href="#id4">最佳实践</a><ul>
<li><a class="reference internal" href="#spring">Spring配置文件:</a></li>
<li><a class="reference internal" href="#spring-cas-client">Spring cas client关键代码</a></li>
<li><a class="reference internal" href="#q-a">Q&amp;A</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5">参考资料</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="webpage.html"
                        title="previous chapter">Web Page Design</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../performance/web_performance.html"
                        title="next chapter">Web Performance</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/_templates/web/cas.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cas">
<h1>Cas<a class="headerlink" href="#cas" title="Permalink to this headline">¶</a></h1>
<p>Central Authentication Service 是开源的单点登录解决方案，本身是一套框架，底层预留出接口进行认证，支持多种认证方式，Cas Client和Cas Server之间
的通讯协议也是支持Cas，OpenId，SAML，Oauth等。</p>
<div class="section" id="id1">
<h2>Cas介绍<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Cas Server: authenticate users, grant access to CAS-enabled services, issue and validate tickets, create sso session;</p>
<p>Cas Client: communicate with CAS server via a supported protocol,  can be integrated with various software platforms and applications;</p>
<p>支持的协议（Protocols）： Custom Protocol 、 CAS 、 OAuth 、 OpenID 、 RESTful API 、 SAML1.1 、 SAML2.0。</p>
<p>支持的认证机制：Active Directory 、 JAAS 、 JDBC 、 LDAP 、 X.509 Certificates。</p>
<p>安全策略：使用票据（Ticket）来实现支持的认证协议；</p>
<p>支持授权：可以决定哪些服务可以请求和验证服务票据（Service Ticket）；</p>
<p>提供高可用性：通过把认证过的状态数据存储在 TicketRegistry 组件中，这些组件有很多支持分布式环境的实现，
如： BerkleyDB 、 Default 、 EhcacheTicketRegistry 、 JDBCTicketRegistry 、 JBOSS TreeCache 、 JpaTicketRegistry 、 MemcacheTicketRegistry 等；</p>
<p>支持多种客户端： Java, .Net, PHP, Perl, Apache, uPortal 等。</p>
<img alt="../../_images/cas_architecture.png" src="../../_images/cas_architecture.png" />
<div class="section" id="id2">
<h3>相关概念<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>TGT: Ticket Granting Ticket;</p>
<p>TGC: Ticket Granting Cookie, TGT in client browser;</p>
<p>ST: Service Ticket;</p>
<p>Credentials：用户提供的用于登录用的凭据信息，如用户名/密码、证书、IP地址、Cookie值等。比如UsernamePasswordCredentials，封装的是用户名和密码。
CAS进行认证的第一步，就是把从UI或request对象里取到的用户凭据封装成Credentials对象，然后交给认证管理器去认证；</p>
<p>AuthenticationHandler：认证Handler, 每种AuthenticationHandler只能处理一种Credentials；</p>
<p>Principal：封装用户标识，比如SimplePrincipal, 只是封装了用户名。认证成功后，credentialsToPrincipalResolvers负责由Credentials生成Principal对象；</p>
<p>CredentialsToPrincipalResolvers：负责由Credentials生成Principal对象，每种CredentialsToPrincipalResolvers 只处理一种Credentials，
比如UsernamePasswordCredentialsToPrincipalResolver负责从UsernamePasswordCredentials中取出用户名，然后将其赋给生成的SimplePrincipal的ID属性；</p>
<p>AuthenticationMetaDataPopulators：负责将Credentials的一些属性赋值给Authentication的attributes属性；</p>
<p>Authentication：Authentication是认证管理器的最终处理结果， Authentication封装了Principal，认证时间，及其他一些属性（可能来自Credentials）；</p>
<p>AuthenticationManager：认证管理器得到Credentials对象后，负责调度AuthenticationHandler去完成认证工作，最后返回的结果是Authentication对象；</p>
<p>CentralAuthenticationService：CAS的服务类，对Web层提供了一些方法。该类还负责调用AuthenticationManager完成认证逻辑；</p>
</div>
</div>
<div class="section" id="id3">
<h2>Cas流程<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>Cas的访问流程分为几个步骤：</p>
<ol class="arabic simple">
<li>用户访问Cas保护的资源时，部署在客户Web应用的ExceptionTranslationFilter，会截获此请求，生成service参数，然后redirect到CAS服务的login接口，
例如：<a class="reference external" href="https://$casserverurl/cas/login?service=http://$webserver/webapp/j_spring_cas_security_check">https://$casserverurl/cas/login?service=http://$webserver/webapp/j_spring_cas_security_check</a>;</li>
</ol>
<img alt="../../_images/cas_process1.jpg" src="../../_images/cas_process1.jpg" />
<ol class="arabic simple" start="2">
<li>用户与Cas Server进行交互，进行身份认证，认证成功后，CAS服务器会生成认证cookie，写入浏览器，同时将SSO session存到服务器本地，
并为客户端浏览器设置一个 Ticket Granted Cookie（TGC），CAS 服务器还会根据service 参数生成ticket,ticket会保存到服务器，
也会加在url后面，然后将请求redirect回客户Web服务器，
例如：<a class="reference external" href="http://$webserver/webapp/j_spring_cas_security_check?ticket=ST-0-ER94xMJmn6pha35CQRoZ">http://$webserver/webapp/j_spring_cas_security_check?ticket=ST-0-ER94xMJmn6pha35CQRoZ</a>;</li>
</ol>
<img alt="../../_images/cas_process2.jpg" src="../../_images/cas_process2.jpg" />
<ol class="arabic simple" start="3">
<li>Web应用的CasAuthenticationFilter会监听上述请求，看到ticket参数后，会跳过，传给AuthenticationManager进行处理，也就是配置中的CasAuthenticationProvider，
由里面配置的的TicketValidationFilter处理，TicketValidationFilter会发送请求到Cas Server的/serviceValidate接口, 将ticket、service都传到此接口，
由此接口验证ticket的有效性，之后Cas Server会给出响应，如果成功的话响应中会包含UserName；
例如：<a class="reference external" href="http://$casserverurl/cas/serviceValidate?ticket=ST-0-ER94xMJmn6pha35CQRoZ&amp;service=$serviceurl">http://$casserverurl/cas/serviceValidate?ticket=ST-0-ER94xMJmn6pha35CQRoZ&amp;service=$serviceurl</a>;</li>
</ol>
<img alt="../../_images/cas_process3.jpg" src="../../_images/cas_process3.jpg" />
<ol class="arabic simple" start="4">
<li>至此为止，SSO就建立起来了，以后用户在同一浏览器里访问此web应用时，AuthenticationFilter会在session里读取到用户信息，所以就不会去CAS认证，
如果在此浏览器里访问别的web 应用时，AuthenticationFilter在session 里读取不到用户信息，会去CAS 的login接口认证，但这时CAS会读取到浏览器传来的cookie，
所以CAS不会要求用户去登录页面登录，只是会根据service参数生成一个ticket ，然后再和web应用做一个验证ticket的交互而已；</li>
<li>Cas登出时，由requestSingleLogoutFilter访问/spring_security_cas_logout重定向到Cas Server来进行登出，再由Cas Server发送一个Single Logout Request到所有
注册的服务中，singleLogoutFilter处理这个Single Logout Request，从静态Map中查找Session并将其置为无效。</li>
<li>整体流程图：</li>
</ol>
<img alt="../../_images/cas_flow_diagram.png" src="../../_images/cas_flow_diagram.png" />
<p>代理流程：</p>
<img alt="../../_images/cas_proxy_flow_diagram.jpg" src="../../_images/cas_proxy_flow_diagram.jpg" />
</div>
<div class="section" id="cas-ha-deployment">
<h2>Cas HA Deployment<a class="headerlink" href="#cas-ha-deployment" title="Permalink to this headline">¶</a></h2>
<p>简单环境，建议使用云平台进行HA，使用Active/Standby方式，这样ticket信息和ticket registry都存储在内存之中，简单有效，不能做到用户零
感知升级和切换，而且切换后会丢失SSO session，导致重新登录。</p>
<p>集群环境，可分为Active/Standby和Active/Active，当使用Active/Active模式时，需要将ticket和ticket registry存储在共享存储上，并使用LBS
的心跳机制，session共享是可选的，但并不推荐，建议使用LBS的source IP方式（大NAT环境下不建议），并提供冗余的服务，Session复制复杂而
不可靠，有安全泄漏的风险。
Active/Standby模式下，切换的时候可能会导致票据验证不通过，这个时候需要重新登录。</p>
<img alt="../../_images/ha_architecture.png" src="../../_images/ha_architecture.png" />
</div>
<div class="section" id="cas-security">
<h2>Cas Security<a class="headerlink" href="#cas-security" title="Permalink to this headline">¶</a></h2>
<p>主要思想为宁可牺牲用户体验，也要保证ticket，session安全。</p>
<ol class="arabic simple">
<li>为了减少帐号密码暴露的风险，所有与Cas Server的交互都建议使用https方式，包括Cas server与底层的认证服务交互，与用户或Cas client的
交互；</li>
<li>不建议使用缓存集群进行同步和复制ticket信息，同时持久化也应该加密；</li>
<li>对于关键应用使用Force Authentication机制；</li>
<li>对于信任ip可使用Passive Authentication机制；</li>
<li>当使用代理模式时对代理链进行验证；</li>
<li>尽量缩短app的session timeout和SSO session的timeout，防止退出出错时造成安全风险；</li>
<li>支持login throttling，但建议使用认证服务器自身的throttling；</li>
<li>对于long term session，使用Force Authentication进行保护；</li>
</ol>
</div>
<div class="section" id="id4">
<h2>最佳实践<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>通过配置来实现自己的Handler</p>
<div class="section" id="spring">
<h3>Spring配置文件:<a class="headerlink" href="#spring" title="Permalink to this headline">¶</a></h3>
<p>web.xml</p>
<div class="code highlight-python"><div class="highlight"><pre><span></span>&lt;!-- Wraps an HttpServletRequest so that the getRemoteUser and getPrincipal return the CAS related entries --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;!-- Places the Assertion in a ThreadLocal for portions of the application that need access to it. This is useful when the Web application
that this filter &quot;fronts&quot; needs to get the Principal name, but it has no access to the HttpServletRequest, hence making getRemoteUser() call impossible --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt;
&lt;/filter&gt;
</pre></div>
</div>
<p>spring-cas.xml</p>
<div class="code highlight-python"><div class="highlight"><pre><span></span>&lt;!-- 声明Cas认证切入点，并声明默认配置为false，以加入自己的定制 --&gt;
&lt;security:http entry-point-ref=&quot;casAuthenticationEntryPoint&quot; auto-config=&quot;false&quot;&gt;
    &lt;!-- 声明被保护的资源，注意顺序，并加入spring security的权限管理 --&gt;
    &lt;security:intercept-url pattern=&quot;/checkauthority.do&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot; /&gt;
    &lt;security:intercept-url pattern=&quot;/\**/\*.cas&quot; access=&quot;ROLE_USER,ROLE_DOCTOR&quot; /&gt;

    &lt;!-- 如果声明默认配置为true，可以仅指定logout-success-url，其余都有默认初始值 --&gt;
    &lt;security:logout logout-success-url=&quot;${cas.securityContext.casProcessingFilterEntryPoint.logoutUrl}?service=${index.url}&quot; /&gt; --&gt;
    &lt;security:custom-filter ref=&quot;concurrencyFilter&quot; position=&quot;CONCURRENT_SESSION_FILTER&quot; /&gt;
    &lt;security:custom-filter ref=&quot;casAuthenticationFilter&quot; position=&quot;CAS_FILTER&quot;/&gt;
    &lt;security:custom-filter ref=&quot;singleLogoutFilter&quot; before=&quot;CAS_FILTER&quot;/&gt;
    &lt;security:custom-filter ref=&quot;requestSingleLogoutFilter&quot; position=&quot;LOGOUT_FILTER&quot;/&gt;
&lt;/security:http&gt;

&lt;bean id=&quot;casAuthenticationEntryPoint&quot; class=&quot;org.springframework.security.cas.web.CasAuthenticationEntryPoint&quot;&gt;
    &lt;property name=&quot;loginUrl&quot; value=&quot;${cas.securityContext.casProcessingFilterEntryPoint.loginUrl}&quot;/&gt;
    &lt;property name=&quot;serviceProperties&quot; ref=&quot;serviceProperties&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;serviceProperties&quot; class=&quot;org.springframework.security.cas.ServiceProperties&quot;&gt;
    &lt;property name=&quot;service&quot; value=&quot;${cas.securityContext.serviceProperties.service}&quot; /&gt;
    &lt;property name=&quot;sendRenew&quot; value=&quot;false&quot; /&gt;
&lt;/bean&gt;

&lt;security:authentication-manager alias=&quot;authenticationManager&quot;&gt;
    &lt;security:authentication-provider ref=&quot;casAuthenticationProvider&quot;/&gt;
&lt;/security:authentication-manager&gt;

&lt;bean id=&quot;casAuthenticationProvider&quot; class=&quot;org.springframework.security.cas.authentication.CasAuthenticationProvider&quot;&gt;
    &lt;property name=&quot;authenticationUserDetailsService&quot; ref=&quot;authenticationUserDetailsService&quot; /&gt;
    &lt;property name=&quot;serviceProperties&quot; ref=&quot;serviceProperties&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;ticketValidator&quot;&gt;
        &lt;!-- Validates the tickets using the CAS 2.0 protocol. If you provide either the acceptAnyProxy or the allowedProxyChains parameters,
        a Cas20ProxyTicketValidator will be constructed. Otherwise a general Cas20ServiceTicketValidator will be constructed that does not accept proxy tickets --&gt;
        &lt;bean class=&quot;org.jasig.cas.client.validation.Cas20ServiceTicketValidator&quot;&gt;
            &lt;constructor-arg index=&quot;0&quot; value=&quot;${cas.securityContext.ticketValidator.casServerUrlPrefix}&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;key&quot; value=&quot;an_id_for_this_auth_provider_only&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;casAuthenticationFilter&quot; class=&quot;org.springframework.security.cas.web.CasAuthenticationFilter&quot;&gt;
    &lt;property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot;/&gt;
    &lt;property name=&quot;authenticationSuccessHandler&quot; ref=&quot;authenticationSuccessHandler&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;authenticationSuccessHandler&quot; class=&quot;com.xikang.ch.cas.MyAuthenticationSuccessHandler&quot;&gt;
    &lt;property name=&quot;alwaysUseDefaultTargetUrl&quot; value=&quot;true&quot; /&gt;
    &lt;property name=&quot;defaultTargetUrl&quot; value=&quot;${index.url}&quot; /&gt;
    &lt;property name=&quot;serverName&quot; value=&quot;${ch.domain}&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;concurrencyFilter&quot; class=&quot;org.springframework.security.web.session.ConcurrentSessionFilter&quot;&gt;
    &lt;property name=&quot;sessionRegistry&quot; ref=&quot;sessionRegistry&quot; /&gt;
    &lt;property name=&quot;expiredUrl&quot; value=&quot;${cas.securityContext.casProcessingFilterEntryPoint.logoutUrl}&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;sessionRegistry&quot; class=&quot;org.springframework.security.core.session.SessionRegistryImpl&quot; /&gt;

&lt;bean id=&quot;authenticationUserDetailsService&quot; class=&quot;com.xikang.ch.cas.GrantedAuthorityFromAssertionAttributesXKUserDetailsService&quot;&gt;
    &lt;constructor-arg&gt;
        &lt;array&gt;
            &lt;value&gt;authorities&lt;/value&gt;
        &lt;/array&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;bean id=&quot;proxyGrantingTicketStorage&quot; class=&quot;org.jasig.cas.client.proxy.ProxyGrantingTicketStorageImpl&quot; /&gt;

&lt;!--登出配置--&gt;

&lt;bean id=&quot;singleLogoutFilter&quot; class=&quot;org.jasig.cas.client.session.SingleSignOutFilter&quot;/&gt;

&lt;bean id=&quot;requestSingleLogoutFilter&quot; class=&quot;org.springframework.security.web.authentication.logout.LogoutFilter&quot;&gt;
    &lt;constructor-arg value=&quot;${cas.securityContext.casProcessingFilterEntryPoint.logoutUrl}&quot; /&gt;
    &lt;constructor-arg&gt;
        &lt;!-- &lt;bean class=&quot;org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler&quot; /&gt; --&gt;
        &lt;bean class=&quot;com.xikang.cn.cas.MySecrityContextLogouthandler&quot;/&gt;
    &lt;/constructor-arg&gt;
    &lt;property name=&quot;filterProcessesUrl&quot; value=&quot;/j_spring_security_logout&quot; /&gt;
&lt;/bean&gt;
</pre></div>
</div>
</div>
<div class="section" id="spring-cas-client">
<h3>Spring cas client关键代码<a class="headerlink" href="#spring-cas-client" title="Permalink to this headline">¶</a></h3>
<p>当用户访问一个被SpringSecurity保护的资源时，会抛出AccessDeniedException或者AuthenticationException，
就会被ExceptionTranslationFilter类探测并解惑；</p>
<p>org.springframework.security.web.access.ExceptionTranslationFilter:</p>
<div class="code java highlight-python"><div class="highlight"><pre><span></span>public class ExceptionTranslationFilter extends GenericFilterBean {

    private AccessDeniedHandler accessDeniedHandler = new AccessDeniedHandlerImpl();
    //认证的切面入口点，这里是casAuthenticationEntryPoint
    private AuthenticationEntryPoint authenticationEntryPoint;
    private AuthenticationTrustResolver authenticationTrustResolver = new AuthenticationTrustResolverImpl();
    private ThrowableAnalyzer throwableAnalyzer = new DefaultThrowableAnalyzer();
    private RequestCache requestCache = new HttpSessionRequestCache();

    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
        try{
            chain.doFilter(request, response);
            logger.debug(&quot;Chain processed normally&quot;);
        }catch (IOException ex) {
            throw ex;
        }catch (Exception ex) {
            // Try to extract a SpringSecurityException from the stacktrace
            Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex);
            RuntimeException ase = (AuthenticationException) throwableAnalyzer.getFirstThrowableOfType(AuthenticationException.class, causeChain);
            if (ase == null) {
                ase = (AccessDeniedException)throwableAnalyzer.getFirstThrowableOfType(AccessDeniedException.class, causeChain);
            }
            if (ase != null) {
                handleSpringSecurityException(request, response, chain, ase);
            }else {
                // Rethrow ServletExceptions and RuntimeExceptions as-is
                if (ex instanceof ServletException) {
                    throw (ServletException) ex;
                }else if (ex instanceof RuntimeException) {
                    throw (RuntimeException) ex;
                }
                // Wrap other Exceptions. This shouldn&#39;t actually happen
                // as we&#39;ve already covered all the possibilities for doFilter&#39;&#39;
                throw new RuntimeException(ex);
            }
        }
    }
    private void handleSpringSecurityException(HttpServletRequest request, HttpServletResponse response, FilterChain chain,
            RuntimeException exception) throws IOException, ServletException {
        if (exception instanceof AuthenticationException) {
            logger.debug(&quot;Authentication exception occurred; redirecting to authentication entry point&quot;, exception);
            sendStartAuthentication(request, response, chain, (AuthenticationException) exception);
        }else if (exception instanceof AccessDeniedException) {
            if (authenticationTrustResolver.isAnonymous(SecurityContextHolder.getContext().getAuthentication())) {
                logger.debug(&quot;Access is denied (user is anonymous); redirecting to authentication entry point&quot;, exception);
                sendStartAuthentication(request, response, chain, new InsufficientAuthenticationException(
                                        &quot;Full authentication is required to access this resource&quot;));
            } else {
                logger.debug(&quot;Access is denied (user is not anonymous); delegating to AccessDeniedHandler&quot;, exception);
                accessDeniedHandler.handle(request, response, (AccessDeniedException) exception);
            }
        }
    }
    protected void sendStartAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain,
            AuthenticationException reason) throws ServletException, IOException {
        SecurityContextHolder.getContext().setAuthentication(null);
        requestCache.saveRequest(request, response);
        logger.debug(&quot;Calling Authentication entry point.&quot;);
        //这里根据authenticationEntryPoint的具体类型重定向到其中的认证页面
        authenticationEntryPoint.commence(request, response, reason);
    }
}
</pre></div>
</div>
<p>Cas Client通过TicketValidationFilter来验证ticket的有效性；</p>
<p>org.jasig.cas.client.validation.AbstractTicketValidationFilter:</p>
<div class="code java highlight-python"><div class="highlight"><pre><span></span>public final void doFilter(final ServletRequest servletRequest, final ServletResponse servletResponse,
   final FilterChain filterChain) throws IOException, ServletException {
   if (!preFilter(servletRequest, servletResponse, filterChain)) {
       return;
   }
   final HttpServletRequest request = (HttpServletRequest) servletRequest;
   final HttpServletResponse response = (HttpServletResponse) servletResponse;
   final String ticket = CommonUtils.safeGetParameter(request, getArtifactParameterName());
   if (CommonUtils.isNotBlank(ticket)) {
       if (log.isDebugEnabled()) {
           log.debug(&quot;Attempting to validate ticket: &quot; + ticket);
       }
       try{
           final Assertion assertion = this.ticketValidator.validate(ticket, constructServiceUrl(request, response));
           if (log.isDebugEnabled()) {
               log.debug(&quot;Successfully authenticated user: &quot; + assertion.getPrincipal().getName());
           }
           request.setAttribute(CONST_CAS_ASSERTION, assertion);
           if (this.useSession) {
               request.getSession().setAttribute(CONST_CAS_ASSERTION, assertion);
           }
           onSuccessfulValidation(request, response, assertion);
       }catch (final TicketValidationException e) {
           response.setStatus(HttpServletResponse.SC_FORBIDDEN);
           log.warn(e, e);
           onFailedValidation(request, response);
           if (this.exceptionOnValidationFailure) {
               throw new ServletException(e);
           }
       }
       if (this.redirectAfterValidation) {
           log. debug(&quot;Redirecting after successful ticket validation.&quot;);
           response.sendRedirect(response.encodeRedirectURL(constructServiceUrl(request, response)));
           return;
       }
   }
   filterChain.doFilter(request, response);
}
</pre></div>
</div>
<p>Cas Client通过CasAuthenticationFilter来监听/j_spring_cas_security_check的请求，进行认证后的filter工作；</p>
<p>org.springframework.security.web.authentication.AbstractrAuthenticationProcessingFilter:</p>
<div class="code java highlight-python"><div class="highlight"><pre><span></span>public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest) req;
    HttpServletResponse response = (HttpServletResponse) res;
    if (!requiresAuthentication(request, response)) {
        chain.doFilter(request, response);
        return;
    }
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Request is to process authentication&quot;);
    }
    Authentication authResult;
    try {
        authResult = attemptAuthentication(request, response);
        if (authResult == null) {
            // return immediately as subclass has indica ted that it hasn&#39;t completed authentication
            return;
        }
        sessionStrategy.onAuthentication(authResult, request, response);
    }catch(InternalAuthenticationServiceException failed) {
        logger.error(&quot;An internal error occurred while trying to authenticate the user.&quot;, failed);
        unsuccessfulAuthentication(request, response, failed);
        return;
    }catch (AuthenticationException failed) {
        unsuccessfulAuthentication(request, response, failed);
        return;
    }
    //Authentication success
    if (continueChainBeforeSuccessfulAuthentication) {
        chain.doFilter(request, response);
    }

    successfulAuthentication(request, response, chain, authResult);
}

protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain,
            Authentication authResult) throws IOException, ServletException{
    successfulAuthentication(request, response, authResult);
}

@Deprecated
protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response,
        Authentication authResult) throws IOException, ServletException {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Authentication success. Updating SecurityContextHolder to contain: &quot; + authResult);
    }
    SecurityContextHolder.getContext().setAuthentication(authResult);
    rememberMeServices.loginSuccess(request, response, authResult);
    if (this.eventPublisher != null) {
        eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));
    }
    successHandler.onAuthenticationSuccess(request, response, authResult);
}
</pre></div>
</div>
<p>通过继承SimpleUrlAuthenticationSuccessHandler来实现自己的登录后逻辑；</p>
<p>org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler</p>
<div class="code java highlight-python"><div class="highlight"><pre><span></span>public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
        Authentication authentication) throws IOException, ServletException {
    handle(request, response, authentication);
    clearAuthenticationAttributes(request);
}

protected final void clearAuthenticationAttributes(HttpServletRequest request) {
    HttpSession session = request.getSession(false);
    if(session == null){
        return;
    }
    session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION);
}

//父类方法
protected void handle(HttpServletRequest request, HttpServletResponse response, Authentication authentication)
        throws IOException, ServletException {
    String targetUrl = determineTargetUrl(request, response);
    if (response.isCommitted()) {
        logger.debug(&quot;Response has already been committed. Unable to redirect to &quot; + targetUrl);
        return;
    }
    redirectStrategy.sendRedirect(request, response, targetUrl);
}
</pre></div>
</div>
<p>通过继承AbstractCasAssertionUserDetailsService来实现用户权限分配；</p>
<p>org.springframework.security.cas.userdetails.AbstractCasAssertionUserDetailsService</p>
<div class="code java highlight-python"><div class="highlight"><pre><span></span>//认证成功后回调，返回用户Code的方法
public abstract class AbstractCasAssertionUserDetailsService implements AuthenticationUserDetailsService{
    public final UserDetails loadUserDetails(final Authentication token) throws UsernameNotFoundException {
        Assert.isInstanceOf(CasAssertionAuthenticationToken.class, token, &quot;The provided token MUST be an instance of CasAssertionAuthenticationToken.class&quot;);
        return loadUserDetails(((CasAssertionAuthenticationToken) token).getAssertion());
    }
}
//空方法，需要继承实现，来编写自己的逻辑
protected abstract UserDetails loadUserDetails(Assertion assertion);
</pre></div>
</div>
<p>通过继承SecurityContextLogoutHandler并注入到LogoutFilter来实现自己的用户登出逻辑，这里可以使用多个Handler；</p>
<p>org.springframework.security.web.authentication.logout.LogoutFilter:</p>
<div class="code java highlight-python"><div class="highlight"><pre><span></span>public LogoutFilter(String logoutSuccessUrl, LogoutHandler... handlers) {
    Assert.notEmpty(handlers, &quot;LogoutHandlers are required&quot;);
    this.handlers = Arrays.asList(handlers);
    Assert.isTrue(!StringUtils.hasLength(logoutSuccessUrl) || UrlUtils.isValidRedirectUrl(logoutSuccessUrl), logoutSuccessUrl + &quot; isn&#39;t a valid redirect URL&quot;);
    SimpleUrlLogoutSuccessHandler urlLogoutSuccessHandler = new SimpleUrlLogoutSuccessHandler();
    if (StringUtils.hasText(logoutSuccessUrl)) {
        urlLogoutSuccessHandler.setDefaultTargetUrl(logoutSuccessUrl);
    }
    logoutSuccessHandler = urlLogoutSuccessHandler;
    setFilterProcessesUrl(&quot;/j_spring_security_logout&quot;);
}
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest) req;
    HttpServletResponse response = (HttpServletResponse) res;
    if (requiresLogout(request, response)) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Logging out user &#39;&quot; + auth + &quot;&#39; and transferring to logout destination&quot;);
        }
        for (LogoutHandler handler : handlers) {
            handler.logout(request, response, auth);
        }
        logoutSuccessHandler.onLogoutSuccess(request, response, auth);
        return;
    }
    chain.doFilter(request, response);
}
</pre></div>
</div>
</div>
<div class="section" id="q-a">
<h3>Q&amp;A<a class="headerlink" href="#q-a" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Cas Client将原始请求URL存放在什么地方？
回答：存放在session之中，key为&#8221;SPRING_SECURITY_SAVED_REQUEST&#8221;；</li>
<li>登录用户再次登录会发生什么情况？
回答：重复登录的情况，Cas Server的Handler会首先判断浏览器发出的请求是否包含TGC，如果有TGC，则直接由TGC来判别身份和授权，如果没有再接收用户名和密码；</li>
<li>如何判断ticket的有效性？
回答：ticket由Cas Server传给Cas Client后，Cas Client为了防止仿冒攻击，会进行二次验证，会请求Cas Server的valiteTicket接口进行验证，
最后解析Server的返回得到是否成功的信息和用户身份后进行session的Assertion建立，即验证成功；</li>
</ol>
</div>
</div>
<div class="section" id="id5">
<h2>参考资料<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://docs.spring.io/spring-security/site/docs/3.1.6.RELEASE/reference/cas.html">http://docs.spring.io/spring-security/site/docs/3.1.6.RELEASE/reference/cas.html</a></p>
<p><a class="reference external" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-cas/">https://www.ibm.com/developerworks/cn/opensource/os-cn-cas/</a></p>
<p><a class="reference external" href="http://blog.csdn.net/dongdong_java/article/details/22293377">http://blog.csdn.net/dongdong_java/article/details/22293377</a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../performance/web_performance.html" title="Web Performance"
             >next</a> |</li>
        <li class="right" >
          <a href="webpage.html" title="Web Page Design"
             >previous</a> |</li>
        <li><a href="../../index.html">knight 1.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, knight.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>