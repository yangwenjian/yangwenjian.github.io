


=======================================
设计模式Head First
=======================================

六大原则：
=======================================
1. **开闭原则（Open Close Principle）**

   开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。
   所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面
   的具体设计中我们会提到这点。
2. **里氏代换原则（Liskov Substitution Principle）**
   
   里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出
   现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基
   类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原
   则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤
   的规范。—— From Baidu 百科
3. **依赖倒转原则（Dependence Inversion Principle）**
   
   这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
4. **接口隔离原则（Interface Segregation Principle）**
   
   这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，
   其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
5. **迪米特法则（最少知道原则）（Demeter Principle）**
   
   为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
6. **合成复用原则（Composite Reuse Principle）**
   
   原则是尽量使用合成/聚合的方式，而不是使用继承。

创建模型（5种）：
======================================

抽象工厂模式
--------------------------------------
有多个抽象产品线，有一个抽象工厂类，根据不同具体工厂类型和产品类型生产出多种产。

工厂模式
--------------------------------------
工厂模式是为了解耦new实例化对象代码所产生的，为的是针对接口的编程，而不是针对实现的编程，将“实现”从“使用”中解耦，也就是将两者完全分离，是工厂模式的核心思想。
抽象工厂方法把每个抽象工厂中的生产对象的方式都改为工厂模式，定义了一组产品的接口，工厂方法就潜伏在抽象工厂里，
依赖倒置原则(Dependency Inversion Principle)的通用原则是：*依赖抽象，不要依赖具体类*。
google在这方面走的更进一步，实现了guice(音/'dgus/)，解决DI(Dependency Injector)问题，具体请参考guice分析与实现。

构建者模式：
---------------------------------------
私有构造函数，利用静态接口build完成对象的构建；

单例模式：
---------------------------------------
私有构造函数，静态私有变量实例；
双重检查加锁模式，在getInstance方法中判断对象是否为空，如果为空，对整个类进行加锁，然后创建对象并返回，这样可以避免给整个方法加锁后性能下降的问题

原型模式（prototype）：
---------------------------------------
生产者拥有一个原型对象，利用clone产生新的对象；

结构模型（7种）：
---------------------------------------

适配器模式
--------------------------------------
不直接拥有被调用者的对象，而是间接拥有，通过适配器类和被调用者类实现同一个接口实现进行调用；
适配器模式的主要目的是解决接口间不兼容的问题,其定义是将一类的接口，转换成客户期望的另一个接口。
适配器让原本接口不兼容的类可以合作无间。
适配器实现目标接口，有一个被适配的类型对象。

装饰者模式
---------------------------------------
拥有一个和自己父类相同的对象，以实现增强自己的目的；
装饰者模式主要是为解决滥用继承带来的代码混乱的问题，例如不同的咖啡配上不同的佐料，不能一一继承;
我们可以使用一个简单的嵌套（装饰者），每加一层佐料，就在外层加一套嵌套，每个类不仅继承自A，并且还有拥有一个A对象;
这样就可以无限的进行扩展，而不会使得代码膨胀，动态地经责任附加到对象上。
当然这样也有缺点，就是外层对象不知道自己含有什么内容，而且包裹层数多了也不利于可读性

代理模式：
---------------------------------------
代理模式就是利用某个抽象类的好的实现代替之前的实现，就是把专业的事情交给专家；
代理模式为另一个对象提供一个替身或者占位符以控制对这个对象的访问。
具体是生成一个代理对象，用户调用它就像调用真正的对象一样，代理对象进行权限和访问控制。
代理和适配器模式的区别在于适配器转换了真正对象的接口，而代理则实现相同的接口。
Java的RMI正式远程代理的一个实现。

桥接模式：
---------------------------------------
抽象层的简单聚合，到了实现层则视为桥接模式；

组合模式:
---------------------------------------
就是一群某个抽象的具体实现像树一样的聚集在这个抽象类之中，其中有一个共同的方法，递归式的调用到每个叶子节点；
组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
其本质是利用组合形成递归原则，将叶子和子节点一视同仁，进行操作。

享元模式（FlyWeight)：
---------------------------------------
就是一个抽象的具体实现对象的集合，实现对象池的模式；

外观模式（Facade）：
---------------------------------------
利用同一的外观类进行封装，降低耦合度；
提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。
**设计原则--最少知识原则：只和你的密友谈话。(减少耦合)**

行为模型（11种）：
-------------------------------------------------------------

命令模式
---------------------------------------
某个对象不直接调用其他对象，而是通过Command解耦的方式进行调用，command.excute(target)进行调用；
命令模式是为了解耦调用者和被调用者实现而设计的。其基础是以下接口：

.. code:: java

    public interface Command{
        public void execute();
        public void undo();
    }

也可以进行组合命令，实现一个组合命令继承自Command，拥有一个command数组，之后通过这个数组实现一系列命令，进行多命令的实现。
命令模式可以用作队列请求，

模板模式
--------------------------------------
与策略模式基本类似，先写好M方法的流程m1;m2;m3...，然后不同的实现由具体的对象决定；
在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
例如将一段算法中的某个步骤提炼为一个抽象方法，而骨架不变，其他设置成final不可覆盖，子类实现这个抽象方法即可。   
也可以在算法的骨架中设计一个hook，一个bool被子类覆盖的bool方法，这样可以实现控制某些算法是否执行。
钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。

**设计原则--好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。**

好莱坞原则提供给我们一个防止“依赖腐败”的方法。（高层组件依赖底层组件，底层组件依赖高层组件，高层组件依赖边侧组件，鞭策组件又依赖底层组建）在好莱坞的原则下，底层组件使用hook挂钩到系统之上，底层系统不调用高层系统，让高层系统调用底层系统。Applet就是一个子类使用hook的好例子，包括init、repaint、start、stop、paint等。

迭代器模式
---------------------------------------
集合可以根据不同的类型创建出不同的迭代器，用来遍历集合；
迭代器模式是为解决集合具体实现的不同来统一封装遍历的接口。不论是哪种具体类型的集合，只要实现createIterator接口即可，然后使用iterator的hasNext和next方法进行调用
**设计原则：一个类应该只有一个引起变化的原因**

责任链模式（Chain of Responsibility):
---------------------------------------
每个Handler持有下一个Handler对象，逐级进行处理，用户不知道哪层进行了处理，隐藏了实现；

策略模式
---------------------------------------
同一个对象O拥有不同的某个接口I的实现，O的同一个方法调用利用之前留好的I的接口调用，实现其接口I即可有丰富的实现；
将不变的属性作为继承，将变化的属性作为接口并拥有，可以减少变化带来的麻烦，减少代码工作量
鸭子将本身属性种类，羽毛等作为基类的属性，将行为单独抽象为一个接口，并按具体的行为实现这个接口
所有鸭子都有setBehavior方法，进行具体的行为设置

观察者模式
---------------------------------------
就像订阅消息一样，所有想得到通知的对象实现Observer接口，等待变化的对象调用这个update接口；
观察者模式是将观察者加入到主题的观察者列表中，如果有更新或者发现，可以推送给每个观察者;
或者让观察者拥有我们的当前主题，观察者可以自行拉取想要的内容;

备忘录模式（Memento）：
---------------------------------------
通过将保存对象的某一状态封装为一个对象并存储的方式，即为备忘录模式；

状态模式
---------------------------------------
O对象还有一个状态对象OS，当对象状态改变时，O对象的行为也发生变化，具体在OS的具体实现中体现；
状态模式允许对象在内部状态改变时改变它的行为，对想看起来好像修改了它的类。
直观来说，是一个类里包含了自己的几种状态，通过外部调用进而切换自己的状态，

中介者模式（Mediator）：
---------------------------------------
为了防止两个对象互相持有对方对象产生的耦合，中介者模式实现了同时持有这两个对象，避免两个对象互相持有的耦合；

解释器模型（Interceptor）：
---------------------------------------
在波兰表达式中常用，或者是词法分析工具中；


模式的模式
--------------------------------------
模式通常被一起使用，并被组合在一个设计模式解决方案中。
符合模式在一个解决方案中结合两个或者多个模式，以解决一般或重复发生的问题。


參考資料：
======================================
htps://github.com/iluwatar/java-design-patterns
