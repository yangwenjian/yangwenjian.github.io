


=======================================
NoSQL and MongoDB
=======================================

SQL vs NoSQL
=======================================

History
---------------------------------------
SQL：persistency, transaction, integration;

NoSQL：non-relational, cluster-friendly,schema-less;

DataModal
---------------------------------------
* Document: mongoDB;
* Column-family: Cassandra, HBASE;
* Graph: Neo4j;
* Key-Value: redis;

其中Document和Key-Value类似，只是Document-base的存储更transparent;

Transaction
---------------------------------------
RDBMS == ACID;

NoSQL == Base;

NoSQL并不那么依赖于事务，只要操作是aggregate boundry的；

single aggregate == atomic, consistency, isolation, durable;

Consistency分为logical和replication，其中logical在单机或者集群sharding时都需要注意，replication在集群中需要注意；

CAP原则：在Partion保证的情况下，只能在consistency和availability做选择；

SQL or NoSQL
---------------------------------------
区别在于组织数据结构的方式

.. code::

    SQL: schema, 组织好的数据，优美的格式，高效的sql查询，join连接多表，ACID，structure unchanging;
         减少重复，防止变化，覆盖业务，交易时事务；

.. code::

    NoSQL: data not clear, flexible, 关联较少， large volumes, cloudcomputing, scale across data centers, rapid development;

MongDB
=======================================
* MongoDB is an open-source document database that provides high performance, high availability, and automatic scaling.
* MongoDB stores data records as BSON documents. BSON is a binary representation of JSON documents, though it contains more data types than JSON. 

Key Feature
---------------------------------------
* High Performance
  
  + reduces I/O activity
  + Indexes support faster queries
* Rich Query Language

  + Data Aggregation
  + Text Search and Geospatial Queries
* High Availability

  + automatic failover
  + data redundancy
* Horizontal Scalability

  + Sharding distributes data across a cluster of machines
  + creating zones of data based on the shard key
* Support for Multiple Storage Engines

  + WiredTiger Storage Engine
  + In-Memory Storage Engine
  + MMAPv1 Storage Engine

Document
---------------------------------------
The maximum BSON document size is 16 megabytes.
The maximum document size helps ensure that a single document cannot use excessive amount of RAM or,
during transmission, excessive amount of bandwidth.

BSON Types
---------------------------------------
ObjectId
```````````````````````````````````````
In MongoDB, each document stored in a collection requires a unique _id field that acts as a primary key.

* a 4-byte value representing the seconds since the Unix epoch
* a 3-byte machine identifier
* a 2-byte process id
* a 3-byte counter, starting with a random value

ObjectId Ordering:

* in the mongo shell, you can access the creation time of the ObjectId, using the ObjectId.getTimestamp() method.
* sorting on an _id field that stores ObjectId values is roughly equivalent to sorting by creation time.
* Only contain one second of temporal resolution, so ObjectId values created within the same second do not have a guaranteed ordering.
* Are generated by clients, which may have differing system clocks.

Data Types:

* String: UTF-8, drivers for each programming language convert from the language’s string format to UTF-8 when serializing and deserializing BSON.
* Timestamps: 64 bit, 32 bits time_t value, 32 bits an incrementing ordinal for operations within a given second..
* Date: 64-bit integer that represends the milliseconds since the Unix epoch; singed.

Objects Comparison:

* Recursively compare key-value pairs in the order that they appear within the BSON object.
* Compare the key field names.
* If the key field names are equal, compare the field values.
* If the field values are equal, compare the next key/value pair (return to step 1). An object without further pairs is less than an object with further pairs.


mongodb高级特性
=======================================
关系维护：MongoDB 引用有两种：手动引用（Manual References）/DBRefs；

MongoDB 覆盖索引查询
>db.users.ensureIndex({gender:1,user_name:1})
>db.users.find({gender:"M"},{user_name:1,_id:0})
也就是说，对于上述查询，MongoDB的不会去数据库文件中查找。相反，它会从索引中提取数据，这是非常快速的数据查询
下面的实例没有排除_id，查询就不会被覆盖：
>db.users.find({gender:"M"},{user_name:1})

mongodb不支持事务，所以，在你的项目中应用时，要注意这点。无论什么设计，都不要要求mongodb保证数据的完整性。
但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作
.. code::

    {
    "address": {
    "city": "Los Angeles",
    "state": "California",
    "pincode": "123"
    },
    "tags": [
    "music",
    "cricket",
    "blogs"
    ],
    "name": "Tom Benzamin"
    }


使用以下命令创建数组索引：
>db.users.ensureIndex({"tags":1})
创建索引后，我们可以这样检索集合的 tags 字段：
>db.users.find({tags:"cricket"})
为了验证我们使用使用了索引，可以使用 explain 命令：
>db.users.find({tags:"cricket"}).explain()
以上命令执行结果中会显示 "cursor" : "BtreeCursor tags_1" ，则表示已经使用了索引。

索引子文档字段
假设我们需要通过city、state、pincode字段来检索文档，由于这些字段是子文档的字段，所以我们需要对子文档建立索引。
为子文档的三个字段创建索引，命令如下：
>db.users.ensureIndex({"address.city":1,"address.state":1,"address.pincode":1})
一旦创建索引，我们可以使用子文档的字段来检索数据：
>db.users.find({"address.city":"Los Angeles"}) 
查询表达不一定遵循指定的索引的顺序，mongodb 会自动优化。所以上面创建的索引将支持以下查询：
>db.users.find({"address.state":"California","address.city":"Los Angeles"}) 

MongoDB Map Reduce
Map-Reduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。MongoDB提供的Map-Reduce非常灵活，对于大规模数据分析也相当实用。

.. code::
     
    db.collection.mapReduce(
    function() {emit(key,value);}, //map 函数
    function(key,values) {return reduceFunction}, //reduce 函数
    {
    out: collection,
    query: document,
    sort: document,
    limit: number
    }
    )

使用 MapReduce 要实现两个函数 Map 函数和 Reduce 函数,Map 函数调用 emit(key, value), 遍历 collection 中所有的记录, 将 key 与 value 传递给 Reduce 函数进行处理。
Map 函数必须调用 emit(key, value) 返回键值对。
参数说明:
map ：映射函数 (生成键值对序列,作为 reduce 函数参数)。
reduce 统计函数，reduce函数的任务就是将key-values变成key-value，也就是把values数组变成一个单一的值value。。
out 统计结果存放集合 (不指定则使用临时集合,在客户端断开后自动删除)。
query 一个筛选条件，只有满足条件的文档才会调用map函数。（query。limit，sort可以随意组合）
sort 和limit结合的sort排序参数（也是在发往map函数前给文档排序），可以优化分组机制
limit 发往map函数的文档数量的上限（要是没有limit，单独使用sort的用处不大）

.. code::

    >db.posts.mapReduce(
    function() { emit(this.user_name,1); },
    function(key, values) {return Array.sum(values)},
    {
    query:{status:"active"},
    out:"post_total"
    }
    )

    {
    "result" : "post_total",
    "timeMillis" : 23,
    "counts" : {
    "input" : 5,
    "emit" : 5,
    "reduce" : 1,
    "output" : 2
    },
    "ok" : 1
    }

MongoDB 全文检索
全文检索对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。
这个过程类似于通过字典中的检索字表查字的过程。


MongoDB 正则表达式
正则表达式是使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。
许多程序设计语言都支持利用正则表达式进行字符串操作。
MongoDB 使用 $regex 操作符来设置匹配字符串的正则表达式。
MongoDB使用PCRE (Perl Compatible Regular Expression) 作为正则表达式语言。
>db.posts.find({post_text:{$regex:"runoob"}})

如果你的文档中字段设置了索引，那么使用索引相比于正则表达式匹配查找所有的数据查询速度更快。
如果正则表达式是前缀表达式，所有匹配的数据将以指定的前缀字符串为开始。例如： 如果正则表达式为 ^tut ，查询语句将查找以 tut 为开头的字符串。
这里面使用正则表达式有两点需要注意：
正则表达式中使用变量。一定要使用eval将组合的字符串进行转换，不能直接将字符串拼接后传入给表达式。否则没有报错信息，只是结果为空！实例如下：
var name=eval("/" + 变量值key +"/i"); 
